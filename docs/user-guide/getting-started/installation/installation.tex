\chapter{Download and installation}
\label{chap:installation}
This chapter is intended to be a general introduction 
on how to download, install and use \Atlas. In particular, 
in \sect{s:requirements} we will present the general 
requirements of the library. In \sect{s:installation} we 
will first describe how to install the third-party packages 
required by \Atlas (if supported by ECMWF) and successively 
we will outline how to install \Atlas. Finally, in \sect{s:using}
we show how to use \Atlas by creating a simple example 
initializes and finalizes the library.


\section{General requirements}
\label{s:requirements}

\Atlas is a Git repository and is provided under the ECMWF Stash 
framework: \url{https://software.ecmwf.int/stash/projects}. This 
can only be accessed by ECMWF staff within the internal intranet.
Occasionally, access can be granted to external partners working 
on a specific project.

\Atlas is currently available under Stash as \Atlas project 
itself or under the European project ESCAPE. These two repositories 
are separated - specifically the \Atlas project under ESCAPE is 
a so-called Git fork of the main \Atlas project.
Given this structure of the \Atlas project, one can find the 
library either in the main repository:\\
\url{https://software.ecmwf.int/wiki/display/ATLAS/Atlas}\\
or in the ESCAPE repository:\\
\url{https://software.ecmwf.int/stash/projects/ESCAPE/repos/atlas/browse}.\\
If you encounter any problem accessing these pages, please contact 
Willem Deconinck (\url{willem.deconinck@ecmwf.int}).

Note that the main \Atlas project is intended for ECMWF internal 
developments, while the \Atlas project under ESCAPE is intended 
for experimental developments within the scalability program.
Note also that \Atlas requires third-party libraries as described 
in the \sect{s:installation} below.

Finally, \Atlas has been tested and works correctly with the 
following compilers: GCC 4.8.1, Intel 13.0.1, 14.0.1 and CCE 
8.2.7, 8.3.1.



\section{Installation}
\label{s:installation}
\Atlas requires a number of third-party libraries. 
Some of them are external third-party libraries not maintained 
by ECMWF - these external libraries are briefly described 
in \sect{s:external-libs}, where we also provide some 
useful links on how to download and install them. 

Some other third-party libraries are developed and maintained 
by ECMWF. For this set of libraries we provide a download and 
installation instructions in \sect{s:ecmwf-libs}.

\subsection{External third-party libraries}
\label{s:external-libs}
\Atlas requires the following external third-party libraries 
(some of the links provided may have changed, so we suggest 
the reader to lookup on the web for these packages):
%
\begin{itemize}
\item \textbf{Git}: Required for project management and to download 
the repository. For use and installation see \url{https://git-scm.com/}
\item \textbf{CMake}: Required for configuration and cross-compilation 
purposes. For use and installation see \url{http://www.cmake.org/}
\item \textbf{MPI}: Required for distributed memory parallelisation.
For use and installation see for instance \url{https://www.open-mpi.org/}
\item \textbf{Python}: For use and installation see \url{https://www.python.org/}.
\item \textbf{OpenMP} (optional): Required for shared memory 
parallelisation. For use and installation see \url{http://openmp.org/wp/}
\item \textbf{boost\_unit\_test} (optional): Required for unit testing 
for C++. For use and installation see \url{http://www.boost.org/}
\item \textbf{CGal} (optional): Required for geometric computations.
For use and installation see \url{http://www.cgal.org/} 
\item \textbf{FFTW} (optional): Required for the Fast Fourier Transform.
For use and installation see \url{http://www.fftw.org/} Note that it needs
to be installed with Fortran support.
\item \textbf{Eigen} (optional): Required for linear algebra operations.
For use and installation see \url{http://eigen.tuxfamily.org/}
\end{itemize}
%
Note that if you are an ECMWF staff member, you have some of the above 
libraries already available through the module system. In particular 
you can load the following packages as follows:
%
\begin{lstlisting}[style=BashStyle]
module load  git  cmake  python  fftw  eigen
\end{lstlisting}
%
If you are not an ECMWF staff member you need to either install them 
manually following the links above or ask your system administrator 
to verify whether these packages are already available within your 
working environment.


\subsection{ECMWF third-party libraries}
\label{s:ecmwf-libs}
\Atlas additionally requires the following libraries developed 
at ECMWF:
%
\begin{itemize}
\item \textbf{ecbuild}: It implements some CMake macros that 
are useful for configuring and cross-compiling \Atlas and the 
other ECMWF third-party libraries required by \Atlas. 
For further information, please visit: 
\url{https://software.ecmwf.int/wiki/display/ECBUILD/ecBuild}.
\item \textbf{eckit}: It implements some useful C/C++ 
functionalities that are usually part of the boost library. 
This allows a better control on them within ECMWF, without 
excessively relying on Boost. For further information, please 
visit: \url{https://software.ecmwf.int/wiki/display/ECKIT/ecKit}
\item \textbf{fckit} (optional): It implements some useful 
Fortran functionalities. For further information, please 
visit: \url{https://software.ecmwf.int/stash/projects/ECSDK/repos/fckit/browse}
\item \textbf{transi} (optional): It implements the spectral 
transform. For further information, please visit:
\url{https://software.ecmwf.int/stash/projects/ATLAS/repos/transi/browse}
\end{itemize}
%
In the following we will outline how to install each of the 
libraries above. 

The first step is to create a folder where to download, build 
and install all the third-party libraries required as well as 
where to build and install \Atlas. Let us call this folder 
\inlsh{myproject}, create it and enter into the folder:
%
\begin{lstlisting}[style=BashStyle]
mkdir -p $(pwd)/myproject
cd myproject
\end{lstlisting}
%
We then need to create the following folder tree:
%
\begin{lstlisting}[style=BashStyle]
SRC=$(pwd)/sources
BUILDS=$(pwd)/builds
INSTALL=$(pwd)/install
BRANCH=develop
mkdir -p $SRC 
mkdir -p $BUILDS 
mkdir -p $INSTALL
\end{lstlisting}
%
where the sources directory will contain the source files
of each library, the builds directory will contain the 
built libraries and the install directory will contain 
the installation of each library.
We can now proceed to the download and installation 
of each of the ECMWF third-party libraries required 
by \Atlas.



\subsubsection{ecbuild}
To download the library and switch to the correct branch called 
\inlsh{develop}, we can type on the terminal the commands reported 
below:
%
\begin{lstlisting}[style=BashStyle]
git clone ssh://git@software.ecmwf.int:7999/ecsdk/ecbuild.git $SRC/ecbuild
cd $SRC/ecbuild
git checkout $BRANCH
\end{lstlisting}
%
This library is constituted by just a few CMake macros 
and it does not need to be compiled nor installed.
We do not need to to any additional step for ecbuild!



\subsubsection{eckit}
To download the library and switch to the correct branch called 
\inlsh{develop}, we can type on the terminal the commands reported 
below:
%
\begin{lstlisting}[style=BashStyle]
git clone ssh://git@software.ecmwf.int:7999/ecsdk/eckit.git $SRC/eckit
cd $SRC/eckit
git checkout $BRANCH
\end{lstlisting}
%
Now that we have downloaded the library and switched 
to the develop branch, we can proceed to build the 
library and install it. We first need to create the 
following folder where the files will be built:
%
\begin{lstlisting}[style=BashStyle]
mkdir $BUILDS/eckit
cd $BUILDS/eckit
\end{lstlisting}
%
Then, we need to run ecbuild in order to configure the 
library - i.e. to find the various dependencies required, 
etc. - and finally we need to run \inlsh{make install} 
to compile and install the library. These two steps are 
reported below:
%
\begin{lstlisting}[style=BashStyle]
$SRC/ecbuild/bin/ecbuild --build=DEBUG --prefix=$INSTALL/eckit -- $SRC/eckit
make -j4 install
\end{lstlisting}
%
Note that the flag \inlsh{-\,-build} allow you to specify which 
building you are going to perform. There are the following 
three options:\\
\inlsh{DEBUG}: No optimisation - used for debugging purposes.\\
\inlsh{BIT}: Maximum optimisation while remaining bit-reproducible.\\
\inlsh{RELEASE}: Maximum optimisation.\\
In addition, the flag \inlsh{-\,-prefix} allows you to specify 
the library installation path. Note that if the folder \inlsh{\$INSTALL/eckit} 
is not already present it will be automatically created.




\subsubsection{fckit (optional)}
To download the library and switch to the correct branch called 
\inlsh{develop}, we can type on the terminal the commands reported 
below:
%
\begin{lstlisting}[style=BashStyle]
git clone ssh://git@software.ecmwf.int:7999/ecsdk/fckit.git $SRC/fckit
cd $SRC/fckit
git checkout $BRANCH
\end{lstlisting}
%
Now that we have downloaded the library and switched 
to the develop branch, we can proceed to build the 
library and install it. We first need to create the 
following folder where the files will be built:
%
\begin{lstlisting}[style=BashStyle]
mkdir $BUILDS/fckit
cd $BUILDS/fckit
\end{lstlisting}
%
Then, we need to run ecbuild in order to configure the 
library - i.e. to find the various dependencies required, 
etc. - and finally we need to run \inlsh{make install} 
to compile and install the library. These two steps are 
reported below:
%
\begin{lstlisting}[style=BashStyle]
$SRC/ecbuild/bin/ecbuild --build=DEBUG --prefix=$INSTALL/fckit -- $SRC/fckit
make -j4 install
\end{lstlisting}
%
Note that the flag \inlsh{-\,-build} allow you to specify which 
building you are going to perform. There are the following 
three options:\\
\inlsh{DEBUG}: No optimisation - used for debugging purposes.\\
\inlsh{BIT}: Maximum optimisation while remaining bit-reproducible.\\
\inlsh{RELEASE}: Maximum optimisation.\\
In addition, the flag \inlsh{-\,-prefix} allows you to specify 
the library installation path. Note that if the folder \inlsh{\$INSTALL/fckit} 
is not already present it will be automatically created.



\subsubsection{transi (optional)}
To download the library and switch to the correct branch called 
\inlsh{develop}, we can type on the terminal the commands reported 
below:
%
\begin{lstlisting}[style=BashStyle]
git clone ssh://git@software.ecmwf.int:7999/atlas/transi.git $SRC/transi
cd $SRC/transi
git checkout $BRANCH
\end{lstlisting}
%
Now that we have downloaded the library and switched 
to the develop branch, we can proceed to build the 
library and install it. We first need to create the 
following folder where the files will be built:
%
\begin{lstlisting}[style=BashStyle]
mkdir $BUILDS/transi
cd $BUILDS/transi
\end{lstlisting}
%
Then, we need to run ecbuild in order to configure the 
library - i.e. to find the various dependencies required, 
etc. - and finally we need to run \inlsh{make install} 
to compile and install the library. These two steps are 
reported below:
%
\begin{lstlisting}[style=BashStyle]
$SRC/ecbuild/bin/ecbuild --build=DEBUG \ 
--prefix=$INSTALL/transi -- $SRC/transi
make -j4 install
\end{lstlisting}
%
Note that the flag \inlsh{-\,-build} allow us to specify which 
building we are going to perform. There are the following 
three options:\\
\hspace{1cm}\inlsh{DEBUG}: No optimisation - used 
for debugging purposes.\\
\hspace{1cm}\inlsh{BIT}: Maximum optimisation while 
remaining bit-reproducible.\\
\hspace{1cm}\inlsh{RELEASE}: Maximum optimisation.\\
In addition, the flag \inlsh{-\,-prefix} allows us to 
specify the library installation path. Note that if 
the folder \inlsh{\$INSTALL/transi} is not already 
present it will be automatically created.



\subsection{\Atlas installation}
Once we have downloaded, compiled and installed the third-party 
dependencies described above, we can now download and install 
\Atlas. In particular, to download the library and switch 
to the correct branch called \inlsh{develop}, we can type 
on the terminal the commands reported below:
%
\begin{lstlisting}[style=BashStyle]
git clone ssh://git@software.ecmwf.int:7999/atlas/atlas.git $SRC/atlas
cd $SRC/atlas
git checkout $BRANCH
\end{lstlisting}
%
Now that we have downloaded the library and switched 
to the develop branch, we can proceed to build the 
library and install it. We first need to create the 
following folder where the files will be built:
%
\begin{lstlisting}[style=BashStyle]
mkdir $BUILDS/atlas
cd $BUILDS/atlas
\end{lstlisting}
%
Then, we need to run \inlsh{ecbuild} in order to configure 
the library - i.e. to find the various dependencies required, 
etc. - and finally we need to run \inlsh{make install} 
to compile and install the library. These two steps are 
reported below:
%
\begin{lstlisting}[style=BashStyle]
$SRC/ecbuild/bin/ecbuild --build=DEBUG --prefix=$INSTALL/atlas \ 
-DECKIT_PATH=$INSTALL/eckit \
-DFCKIT_PATH=$INSTALL/fckit \
-DTRANSI_PATH=$INSTALL/transi \
-- $SRC/atlas
make -j4 install
\end{lstlisting}
%
Note again that the flag \inlsh{-\,-build} allow us to specify 
which building we are going to perform. There are the following 
three options:\\
\hspace{1cm}\inlsh{DEBUG}: No optimisation - used 
for debugging purposes.\\
\hspace{1cm}\inlsh{BIT}: Maximum optimisation while 
remaining bit-reproducible.\\
\hspace{1cm}\inlsh{RELEASE}: Maximum optimisation.\\
In addition, the flag \inlsh{-\,-prefix} allows us to 
specify the library installation path. Note that if 
the folder \inlsh{\$INSTALL/atlas} is not already 
present it will be automatically created.

The following extra flags may be added to the \inlsh{ecbuild} 
step to fine-tune configuration:
%
\begin{lstlisting}[style=BashStyle]
-DENABLE_OMP=OFF --- Disable OpenMP
-DENABLE_MPI=OFF --- Disable MPI
-DENABLE_FORTRAN=OFF --- Disable Compilation of Fortran bindings
\end{lstlisting}
%
%
\begin{notebox}
By default compilation is done using shared libraries. Some systems have 
linking problems with static libraries that have not been compiled with 
the flag \inlsh{-fPIC}. In this case, also compile atlas using static 
linking, by adding to the ecbuild step the flag: \inlsh{-DBUILD\_SHARED\_LIBS=OFF}
\end{notebox}
%
The building and installation of \Atlas should now be complete 
and you can start using it - with this purpose, in the next 
section we show a simple example on how to create a simple 
program to initialize and finalize the library.




\section{Using the library}
\label{s:using}
In this section, we provide a simple example on how to use the 
library. The objective here is not to get familiar with the main 
functionalities of \Atlas, but rather to show how to get started!
Specifically, we will show a simple program the initializes and 
finalizes the library and we will detail the steps necessary to
compile and run the program.

Note that the library supports both C++ and Fortran, therefore, 
in the following, we will show both an example using C++ and 
an example using Fortran. Before starting, we create a folder 
called \inlsh{project1} in the \inlsh{sources} directory:
%
\begin{lstlisting}[style=BashStyle]
mkdir -p $SRC/project1
\end{lstlisting}
%
Here, we will add both the C++ and Fortran files of this 
simple example. Note that there are (at least) two ways 
to compile the code we are going to write. The first involves 
just using a C compiler for the C++ version and a Fortran 
compiler for the Fortran version, without using any cmake 
files. The second involves using cmake files. In the following, 
we will detail both possibilities.

\subsection{C++ version}
\label{s:atlas-usage-example-C}

\subsubsection*{Program description}
The C++ version of the \Atlas initialization and finalization
calls is depicted in \lista{code1-C}.
%
\lstinputlisting[caption=Initialization and finalization 
of \Atlas using C++, style=CStyle, label=code1-C]{usage-example.cc}
%
We can create a new file in the folder \inlsh{project1} just generated:
%
\begin{lstlisting}[style=BashStyle]
touch $SRC/project1/usage-example.cc
\end{lstlisting}
%
and copy the content of the code in \lista{code1-C} into it.
We can now have a closer look at the code.
On line 1, we include the \Atlas header file, we successively 
specify a simple main function, in which we call the initialization 
of the \Atlas library on line 5.
Note that we passed the two arguments of the main function 
\inltc{argc} and \inltc{argv} to the \inltc{atlas\_initialize} 
function.
We finally call the \Atlas \inltc{atlas\_finalize()} function 
at line 6 without passing any argument to it.

The function \inltc{atlas\_initialize()} is responsible for 
the login and for the initialization of MPI (Message Passage 
Interface), while the function \inltc{atlas\_finalize()} 
is responsible for finalizing MPI and closing the program.

\subsubsection*{Code compilation}
We now need to compile the code. We first create a new directory
into the \inlsh{\$BUILDS} folder, where we will compile the code
%
\begin{lstlisting}[style=BashStyle]
mkdir -p $BUILDS/project1
\end{lstlisting}
%
As mentioned above, there are (at least) two ways for compiling 
the source code above. These are detailed below.
%
\begin{description}
%
\item \underline{C compiler - gcc}\\[0.5em]
%
The first possibility is to 
avoid using cmake and ecbuild and directly run a C compiler, 
such as gcc. For doing so, we need to know all the libraries 
linked to \Atlas. This step can be easily achieved by inspecting 
the file 
%
\begin{lstlisting}[style=BashStyle]
vi $INSTALL/atlas/lib/pkgconfig/atlas.pc
\end{lstlisting}
%
Here, all the flags necessary for the correct compilation 
of the C++ code in \lista{code1-C} are reported. For 
compiling the code, we first go into the builds directory 
just created and we generate a new folder where the executables 
will be stored: 
%
\begin{lstlisting}[style=BashStyle]
cd $BUILDS/project1
mkdir -p bin
\end{lstlisting}
%
Note that, when using the cmake compilation route, it is not 
necessary to generate the bin directory since it will automatically 
created during compilation.
After having generated the bin folder, we can run the following 
command:
%
\begin{lstlisting}[style=BashStyle]
gcc $SRC/project1/usage-example.cc -o bin/atlas_c-usage-example \ 
$(pkg-config $INSTALL/atlas/lib/pkgconfig/atlas.pc --libs --cflags)
\end{lstlisting}
%
This will compile our usage-example.cc file and it will automatically 
link all the static and dynamic libraries required by the program. 
The executable, as mentioned, is generated into the folder bin.
%
\item \underline{Cmake/ecbuild}\\[0.5em]
%
The second possibility is to use a cmake file that uses some 
ecbuild macros. In particular, we need to create the following 
cmake file
%
\begin{lstlisting}[style=XMLStyle]
cmake_minimum_required(VERSION 2.8.4 FATAL_ERROR)
project(usage_example)

include(ecbuild_system NO_POLICY_SCOPE)
ecbuild_requires_macro_version(1.9)
ecbuild_declare_project()
ecbuild_use_package(PROJECT atlas REQUIRED)
ecbuild_add_executable(TARGET  atlas_c-usage_example
                       SOURCES usage-example.cc 
                       INCLUDES ${ATLAS_INCLUDE_DIRS}
                                ${CMAKE_CURRENT_BINARY_DIR}
                       LIBS  atlas)
ecbuild_print_summary()
\end{lstlisting}
in the sources folder of our project \inlsh{\$SRC/project1}.
We can create the \inlsh{CMakeLists.txt} file in the correct 
directory following the two steps below:
%
\begin{lstlisting}[style=BashStyle]
cd $SRC/project1
touch CMakeLists.txt
\end{lstlisting}
%
and copy the cmake code above into it.
In the first line of the cmake file above, we declare the minimum 
cmake version required to compile the code, while in the second 
line we declare the name of our cmake project. 
From line 4 to line 6 we include some required ecbuild macros 
necessary for using ecbuild. On line 7 we specify that the 
\Atlas library is required for this project. Finally, on line 
8 we  add the file we want to compile. Line 13 prints just a 
compilation summary.
We can now run this simple cmake file by going into our builds 
directory 
%
\begin{lstlisting}[style=BashStyle]
cd $BUILDS/project1
\end{lstlisting}
%  
and by typing the following command:
%
\begin{lstlisting}[style=BashStyle]
$SRC/ecbuild/bin/ecbuild -DATLAS_PATH=$INSTALL/atlas $SRC/project1/
make 
\end{lstlisting}
%  
Note that in the above command we needed to provide the path 
to the \Atlas library installation. This completes the compilation 
of our first example that uses \Atlas and generates an executable 
file into the bin folder (automatically generated by cmake) 
inside our builds directory for project1.
\end{description}
%

\subsubsection*{Run the code}
After the compilation of the source code is completed, 
we have an executable file into the folder \inlsh{\$BUILDS/project1/bin/}.
If we simply run the executable file as follows:
%
\begin{lstlisting}[style=BashStyle]
./atlas_c-usage-example
\end{lstlisting}
% 
we obtain no output. However, by typing some command 
line instructions we can retrieve some useful information. 
In particular, if we type:
%
\begin{lstlisting}[style=BashStyle]
./atlas_c-usage-example --debug
\end{lstlisting}
%
we should obtain something similar to the following output:
%
\begin{lstlisting}[style=BashStyle]
[0] (2016-02-08 T 14:38:44) (D) -- Atlas program [atlas_c-usage-example]
[0] (2016-02-08 T 14:38:44) (D) --   atlas version [0.5.0]
[0] (2016-02-08 T 14:38:44) (D) --   atlas git \
    [6029971d84e5ce270df59178fbf7b7ffd7b11ceb]
[0] (2016-02-08 T 14:38:44) (D) --   eckit version [0.11.0]
[0] (2016-02-08 T 14:38:44) (D) --   eckit git \
    [8ad599502572a065205ce9212801007f3ca7eafb]
[0] (2016-02-08 T 14:38:44) (D) --   Configuration read from scripts:
[0] (2016-02-08 T 14:38:44) (D) --   rundir  : \ 
    /home/na/nagm/myproject/builds/project1
[0] (2016-02-08 T 14:38:44) (D) -- Atlas finalized
\end{lstlisting}
%
which gives us some information such as the version of \Atlas we are 
running, the identifier of the commit and the path of the executable. 



\subsection{Fortran version}
\label{s:atlas-usage-example-F}

\subsubsection*{Program description}
The Fortran version of the \Atlas initialization and finalization 
calls is depicted in \lista{code1-F}.
%
\lstinputlisting[caption=Initialization and finalization of 
\Atlas using Fortran, style=FStyle, label=code1-F]{usage-example.F90}
%
We can create a new file in the folder \inlsh{project1} just generated:
%
\begin{lstlisting}[style=BashStyle]
touch $SRC/project1/usage-example.F90
\end{lstlisting}
%
and copy the content of the code in \lista{code1-F} into it.
We can now have a closer look at the code.
On line 1, we define the program, called \inltf{usage\_example}.
On line 3, we include the required \Atlas libraries
(note that we include only the two functions required 
for this example - i.e. \inltf{atlas\_init} and \inltf{atlas\_finalize}).
We finally call the two functions \inltf{atlas\_init()} 
on lines 5 and 6 and we close the program on line 8.

The function \inltf{atlas\_init()} is responsible for the login 
and for the initialization of MPI (Message Passage Interface), 
while the function \inltf{atlas\_finalize()} is responsible for
finalizing MPI and closing the program.



\subsubsection*{Code compilation}
We now need to compile the code. We first create a new directory
into the \inlsh{\$BUILDS} folder, where we will compile the code
%
\begin{lstlisting}[style=BashStyle]
mkdir -p $BUILDS/project1
\end{lstlisting}
%
As mentioned above, there are (at least) two ways for compiling 
the source code above. These are detailed below.
%
\begin{description}
%
\item \underline{Fortran compiler - gfortran}\\[0.5em]
%
The first possibility is to 
avoid using cmake and ecbuild and directly run a Fortran compiler, 
such as gfortran. For doing so, we need to know all the libraries 
linked to \Atlas. This step can be easily achieved by inspecting 
the file 
%
\begin{lstlisting}[style=BashStyle]
vi $INSTALL/atlas/lib/pkgconfig/atlas.pc
\end{lstlisting}
%
Here, all the flags necessary for the correct compilation 
of the Fortran code in \lista{code1-F} are reported. For 
compiling the code, we first go into the builds directory 
just created and we generate a new folder where the executables 
will be stored: 
%
\begin{lstlisting}[style=BashStyle]
cd $BUILDS/project1
mkdir -p bin
\end{lstlisting}
%
Note that, when using the cmake compilation route, it is not 
necessary to generate the bin directory since it will automatically 
created during compilation.
After having generated the bin folder, we can run the following 
command:
%
\begin{lstlisting}[style=BashStyle]
gfortran $SRC/project1/usage-example.F90 -o bin/atlas_f-usage-example \ 
$(pkg-config $INSTALL/atlas/lib/pkgconfig/atlas.pc --libs --cflags)
\end{lstlisting}
%
This will compile our usage-example.F90 file and it will automatically 
link all the static and dynamic libraries required by the program. 
The executable, as mentioned, is generated into the folder bin.
%
\item \underline{Cmake/ecbuild}\\[0.5em]
%
The second possibility is to use a cmake file that uses some 
ecbuild macros. In particular, we need to create the following 
cmake file:
%
\begin{lstlisting}[style=XMLStyle]
cmake_minimum_required(VERSION 2.8.4 FATAL_ERROR)
project(usage_example)

include(ecbuild_system NO_POLICY_SCOPE)
ecbuild_requires_macro_version(1.9)
ecbuild_declare_project()
ecbuild_enable_fortran(REQUIRED MODULE_DIRECTORY 
                                ${CMAKE_BINARY_DIR}/module)
ecbuild_use_package(PROJECT atlas REQUIRED)
ecbuild_add_executable(TARGET  atlas_f-usage_example
                       SOURCES usage-example.F90 
                       INCLUDES ${ATLAS_INCLUDE_DIRS}
                                ${CMAKE_CURRENT_BINARY_DIR}
                       LIBS  atlas_f)
ecbuild_print_summary()
\end{lstlisting}
%
in the sources folder of our project \inlsh{\$SRC/project1}.
We can create the \inlsh{CMakeLists.txt} file in the correct 
directory following the two steps below:
%
\begin{lstlisting}[style=BashStyle]
cd $SRC/project1
touch CMakeLists.txt
\end{lstlisting}
%
and copy the cmake code above into it.
In the first line of the cmake file, we declare the minimum cmake 
version required to compile the code, while in the second line 
we declare the name of our cmake project. 
From line 4 to line 6 we include some required ecbuild macros 
necessary for using ecbuild. On line 7 we enable Fortran compilation, 
while on line 9 we specify that the \Atlas library is required for 
this project. Finally, on line 10 we add the file we want to compile. 
Line 15 prints just a compilation summary. We can now run this simple 
cmake file by going into our builds directory 
%
\begin{lstlisting}[style=BashStyle]
cd $BUILDS/project1
\end{lstlisting}
%  
and by typing the following command:
%
\begin{lstlisting}[style=BashStyle]
$SRC/ecbuild/bin/ecbuild -DATLAS_PATH=$INSTALL/atlas $SRC/project1/
make 
\end{lstlisting}
%  
Note that in the above command we needed to provide the path 
to the \Atlas library installation. This completes the compilation 
of our first example that uses \Atlas and generates an executable 
file into the bin folder (automatically generated by cmake) inside
our builds directory for project1.
\end{description}
%

\subsubsection*{Run the code}
After the compilation of the source code is completed, 
we have an executable file into the folder \inlsh{\$BUILDS/project1/bin/}.
If we simply run the executable file as follows:
%
\begin{lstlisting}[style=BashStyle]
./atlas_f-usage-example
\end{lstlisting}
% 
we obtain no output. However, by typing some command 
line instructions we can retrieve some useful information. 
In particular, if we type:
%
\begin{lstlisting}[style=BashStyle]
./atlas_f-usage-example --debug
\end{lstlisting}
%
we should obtain something similar to the following output:
%
\begin{lstlisting}[style=BashStyle]
[0] (2016-02-08 T 14:37:34) (D) -- Atlas program [atlas_f-usage-example]
[0] (2016-02-08 T 14:37:34) (D) --   atlas version [0.5.0]
[0] (2016-02-08 T 14:37:34) (D) --   atlas git \
    [6029971d84e5ce270df59178fbf7b7ffd7b11ceb]
[0] (2016-02-08 T 14:37:34) (D) --   eckit version [0.11.0]
[0] (2016-02-08 T 14:37:34) (D) --   eckit git \
    [8ad599502572a065205ce9212801007f3ca7eafb]
[0] (2016-02-08 T 14:37:34) (D) --   Configuration read from scripts:
[0] (2016-02-08 T 14:37:34) (D) --   rundir  : \ 
    /home/na/nagm/myproject/builds/project1
[0] (2016-02-08 T 14:37:34) (D) -- Atlas finalized
\end{lstlisting}
%
which gives us some information such as the version of \Atlas we are 
running, the identifier of the commit and the path of the executable. 

\begin{tipbox}
The outputs obtained for the Fortran and C++ versions should be identical
since they call exactly the same routines. 
\end{tipbox}

This completes your first project that uses the \Atlas library.






