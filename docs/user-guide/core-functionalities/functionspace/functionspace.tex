\chapter{Using the functionspace objects}
In this chapter, we show how to use the functionspace 
objects. These objects are intended to interpret a 
given field. In particular, by using them on a given 
field, we equip the field with the communication pattern 
(thus the Field knows about parallelism), and it allows 
some simple operations on the field. The functionspace 
objects that will be presented in this chapter are the 
following three:
%
\begin{itemize}
\item \inltc{Nodes}: It relates a given field to the underlying 
mesh, thus enabling the field to parallel communication. 
It also allows some simple operations on the Field, such 
as calculating minimum and maximum values, going from a 
local (to a parallel partition) to a global indexing and 
viceversa, etc.
\item \inltc{ReducedGridPoint}: It relates 
a given field to the underlying reduced grid, thus enabling 
the field to parallel communication. It also allows similar 
operations as the \inltc{Nodes} functionspace, such as going 
from a local to a global indexing and viceversa.
\item \inltc{Spectral}: It allows the spectral representation 
of a Field (no relation to a grid or a mesh here!). The parallelisation 
in this case is achieved through the \inlsh{Trans} 
library.
\end{itemize}
%
For each of the functionspaces presented in the following, 
we show both the C++ and Fortran version.

\section{Nodes}
\subsection{C++ version}
The \lista{code-nodes-C} shows how to construct a mesh 
starting from a grid that can be specified as a command 
line argument. In particular, we use the third-party 
\textit{eckit} object called \inltc{Resource} to define 
the command-line behaviour as done in the previous chapter. 
We have also added an additional command line argument 
called \inlsh{-\,-visualize}. This will allow us to 
visualize the mesh either in 2D or 3D. 
%
\lstinputlisting[caption=Functionspace nodes usage using C++, 
style=CStyle, label=code-fields-C]{nodes.cc}
%
Once defined the command-line behaviour, we first create 
a global reduced-grid object (see line 24). For more 
details on how to create a grid see \chap{chap:global-grids}.

We successively create a mesh object, \inltc{meshPtr} 
that is a \inltc{Mesh::Ptr} type. We then create a 
\inltc{ReducedGridMeshGenerator} object called \inltc{generate\_mesh}
that will allow us to generate the mesh starting from
a reduced grid. We finally create the mesh on line 28.

In this simple example we took the freedom to add a few 
lines to show how to visualize the mesh in Gmsh. In particular, 
on line 30 we define a Gmsh object called \inltc{gmsh} that 
will be used to generate a Gmsh output. On line 31 we specify 
that we want to have some information regarding the mesh - this 
is achieved by defining as \inltc{true} the tag \inltc{"info"}.
Between line 32 and 36, we add two additional lines to visualize 
the mesh in 3D if required on the command-line.
Finally, on line 37 we write the mesh and save it into \inltc{mesh.msh}.
Note that the file containing the information on the mesh 
just created is called \inltc{mesh\_info.msh}.

It is now possible to run this simple program by using 
two command-line arguments representing the keyword that 
identifies an \Atlas predefined grid and the visualization 
type we want (either 2D or 3D), respectively. For instance, 
we can execute the following command line
%
\begin{lstlisting}[style=BashStyle]
./atlas_c-meshes-Reduced --grid O32 --visualize 3D
\end{lstlisting}
% 
This will produce an octahedral reduced Gaussian mesh 
(stored in mesh.msh) with 32 latitudes on one emisphere 
(i.e. 64 latitudes in total). It will also produce an 
additional file, called \inltc{mesh\_info.msh}, containing
some information regarding the mesh.
Note that we used the additional command-line argument 
\inlsh{--visualize 3D}. This will produce a 3D representation 
of the mesh, such as the one depicted in left side of 
\fig{fig:meshes}.

We can re-run the executable file in order to obtain 
a 2D representation as follows:
%
\begin{lstlisting}[style=BashStyle]
./atlas_c-meshes-Reduced --grid O32 --visualize 2D
\end{lstlisting}
% 
This will produce a representation of the mesh like 
the one depicted on the right side of \fig{fig:meshes}.
You can now play with the command-line argument to generate 
different types of global reduced meshes using the keys 
introduced in \chap{chap:global-grids}!




\subsection{Fortran version}
The \lista{code-nodes-F} shows how to construct a mesh 
starting from a grid that can be specified as a command 
line argument. In particular, we use the third-party 
\textit{eckit} object called \inltc{Resource} to define 
the command-line behaviour as done in the previous chapter. 

Once defined the command-line behaviour, we first create 
a global reduced-grid object (see line 13). For more 
details on how to create a grid see \chap{chap:global-grids}.

We successively create the mesh object on line 15 and 16.
In particular, we first define a \inltc{reducedgridmeshgenerator} 
object that is then used to effectively generate the mesh object 
\inltc{mesh} that is an \inltc{atlas\_mesh} type.

In this simple example we took the freedom to add just one line 
line to visualize the mesh in Gmsh. In particular, on line 17 
we call \inltc{atlas\_write\_gmsh} to write a Gmsh file called 
\inlsh{mesh.msh}. Note that at the end of the program we also 
need to destroy the local object created in this program (see 
lines 19 to 21).

It is now possible to run this simple program by using 
a command-line arguments representing the keyword that 
identifies an \Atlas predefined grid. For instance, 
we can execute the following command line
%
\begin{lstlisting}[style=BashStyle]
./atlas_c-meshes-Reduced --grid O32
\end{lstlisting}
% 
This will produce an octahedral reduced Gaussian mesh 
(stored in mesh.msh) with 32 latitudes on one emisphere 
(i.e. 64 latitudes in total).
If we visualize it in Gmsh, we will obtain something similar
to \fig{fig:meshes}.

You can now play with the command-line argument to generate 
different types of global reduced meshes using the keys 
introduced in \chap{chap:global-grids}!
\section{ReducedGridPoint}
\section{Spectral}

